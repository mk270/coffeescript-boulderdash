// Generated by CoffeeScript 1.4.0
(function() {
  var DIR, DIRX, DIRY, Dom, Entity, Game, KEY, Point, Render, Sequences, addEvents, array_of_tuples, game, horizontal, isButterfly, isFirefly, key, keydown, keyup, load, moving, random, randomChoice, randomInt, render, rotateLeft, rotateRight, run, showStats, stats, timestamp, vertical;

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
      return window.setTimeout(callback, 1000 / 60);
    };
  }

  array_of_tuples = function(l) {
    var i, k, tmp, v, _i, _len;
    tmp = [];
    for (_i = 0, _len = l.length; _i < _len; _i++) {
      i = l[_i];
      k = i[0], v = i[1];
      tmp[k] = v;
    }
    return tmp;
  };

  Dom = {
    get: function(id) {
      if (id instanceof HTMLElement) {
        return id;
      } else {
        return document.getElementById(id);
      }
    },
    set: function(id, html) {
      return Dom.get(id).innerHTML = html;
    },
    disable: function(id, enabled) {
      return Dom.get(id).className = enabled ? "disabled" : "";
    }
  };

  DIR = {
    UP: 0,
    UPRIGHT: 1,
    RIGHT: 2,
    DOWNRIGHT: 3,
    DOWN: 4,
    DOWNLEFT: 5,
    LEFT: 6,
    UPLEFT: 7
  };

  DIRX = [0, 1, 1, 1, 0, -1, -1, -1];

  DIRY = [-1, -1, 0, 1, 1, 1, 0, -1];

  Entity = {
    SPACE: {
      code: 0x00,
      rounded: false,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 0,
        y: 6
      },
      flash: {
        x: 4,
        y: 0
      }
    },
    DIRT: {
      code: 0x01,
      rounded: false,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 1,
        y: 7
      }
    },
    BRICKWALL: {
      code: 0x02,
      rounded: true,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 3,
        y: 6
      }
    },
    MAGICWALL: {
      code: 0x03,
      rounded: false,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 4,
        y: 6,
        f: 4,
        fps: 20
      }
    },
    PREOUTBOX: {
      code: 0x04,
      rounded: false,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 1,
        y: 6
      }
    },
    OUTBOX: {
      code: 0x05,
      rounded: false,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 1,
        y: 6,
        f: 2,
        fps: 4
      }
    },
    STEELWALL: {
      code: 0x07,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 1,
        y: 6
      }
    },
    FIREFLY1: {
      code: 0x08,
      rounded: false,
      explodable: true,
      vulnerable: true,
      sprite: {
        x: 0,
        y: 9,
        f: 8,
        fps: 20
      }
    },
    FIREFLY2: {
      code: 0x09,
      rounded: false,
      explodable: true,
      vulnerable: true,
      sprite: {
        x: 0,
        y: 9,
        f: 8,
        fps: 20
      }
    },
    FIREFLY3: {
      code: 0x0A,
      rounded: false,
      explodable: true,
      vulnerable: true,
      sprite: {
        x: 0,
        y: 9,
        f: 8,
        fps: 20
      }
    },
    FIREFLY4: {
      code: 0x0B,
      rounded: false,
      explodable: true,
      vulnerable: true,
      sprite: {
        x: 0,
        y: 9,
        f: 8,
        fps: 20
      }
    },
    BOULDER: {
      code: 0x10,
      rounded: true,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 0,
        y: 7
      }
    },
    BOULDERFALLING: {
      code: 0x12,
      rounded: false,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 0,
        y: 7
      }
    },
    DIAMOND: {
      code: 0x14,
      rounded: true,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 0,
        y: 10,
        f: 8,
        fps: 20
      }
    },
    DIAMONDFALLING: {
      code: 0x16,
      rounded: false,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 0,
        y: 10,
        f: 8,
        fps: 20
      }
    },
    EXPLODETOSPACE0: {
      code: 0x1B,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 3,
        y: 7
      }
    },
    EXPLODETOSPACE1: {
      code: 0x1C,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 4,
        y: 7
      }
    },
    EXPLODETOSPACE2: {
      code: 0x1D,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 5,
        y: 7
      }
    },
    EXPLODETOSPACE3: {
      code: 0x1E,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 4,
        y: 7
      }
    },
    EXPLODETOSPACE4: {
      code: 0x1F,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 3,
        y: 7
      }
    },
    EXPLODETODIAMOND0: {
      code: 0x20,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 3,
        y: 7
      }
    },
    EXPLODETODIAMOND1: {
      code: 0x21,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 4,
        y: 7
      }
    },
    EXPLODETODIAMOND2: {
      code: 0x22,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 5,
        y: 7
      }
    },
    EXPLODETODIAMOND3: {
      code: 0x23,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 4,
        y: 7
      }
    },
    EXPLODETODIAMOND4: {
      code: 0x24,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 3,
        y: 7
      }
    },
    PREROCKFORD1: {
      code: 0x25,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 1,
        y: 6,
        f: 2,
        fps: 4
      }
    },
    PREROCKFORD2: {
      code: 0x26,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 1,
        y: 0
      }
    },
    PREROCKFORD3: {
      code: 0x27,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 2,
        y: 0
      }
    },
    PREROCKFORD4: {
      code: 0x28,
      rounded: false,
      explodable: false,
      vulnerable: false,
      sprite: {
        x: 3,
        y: 0
      }
    },
    BUTTERFLY1: {
      code: 0x30,
      rounded: false,
      explodable: true,
      vulnerable: true,
      sprite: {
        x: 0,
        y: 11,
        f: 8,
        fps: 20
      }
    },
    BUTTERFLY2: {
      code: 0x31,
      rounded: false,
      explodable: true,
      vulnerable: true,
      sprite: {
        x: 0,
        y: 11,
        f: 8,
        fps: 20
      }
    },
    BUTTERFLY3: {
      code: 0x32,
      rounded: false,
      explodable: true,
      vulnerable: true,
      sprite: {
        x: 0,
        y: 11,
        f: 8,
        fps: 20
      }
    },
    BUTTERFLY4: {
      code: 0x33,
      rounded: false,
      explodable: true,
      vulnerable: true,
      sprite: {
        x: 0,
        y: 11,
        f: 8,
        fps: 20
      }
    },
    ROCKFORD: {
      code: 0x38,
      rounded: false,
      explodable: true,
      vulnerable: true,
      sprite: {
        x: 0,
        y: 0
      },
      left: {
        x: 0,
        y: 4,
        f: 8,
        fps: 20
      },
      right: {
        x: 0,
        y: 5,
        f: 8,
        fps: 20
      },
      blink: {
        x: 0,
        y: 1,
        f: 8,
        fps: 20
      },
      tap: {
        x: 0,
        y: 2,
        f: 8,
        fps: 20
      },
      blinktap: {
        x: 0,
        y: 3,
        f: 8,
        fps: 20
      }
    },
    AMOEBA: {
      code: 0x3A,
      rounded: false,
      explodable: true,
      vulnerable: false,
      sprite: {
        x: 0,
        y: 8,
        f: 8,
        fps: 20
      }
    }
  };

  for (key in Entity) {
    Entity[key].name = key;
    Entity[Entity[key].code] = Entity[key];
  }

  rotateLeft = function(dir) {
    return (dir - 2) + (dir < 2 ? 8 : 0);
  };

  rotateRight = function(dir) {
    return (dir + 2) - (dir > 5 ? 8 : 0);
  };

  horizontal = function(dir) {
    return (dir === DIR.LEFT) || (dir === DIR.RIGHT);
  };

  vertical = function(dir) {
    return (dir === DIR.UP) || (dir === DIR.DOWN);
  };

  Point = function(x, y, dir) {
    this.x = x + (DIRX[dir] || 0);
    return this.y = y + (DIRY[dir] || 0);
  };

  isFirefly = function(o) {
    return (Entity.FIREFLY1.code <= o.code) && (o.code <= Entity.FIREFLY4.code);
  };

  isButterfly = function(o) {
    return (Entity.BUTTERFLY1.code <= o.code) && (o.code <= Entity.BUTTERFLY4.code);
  };

  Sequences = {
    FIREFLIES: array_of_tuples([[DIR.LEFT, Entity.FIREFLY1], [DIR.UP, Entity.FIREFLY2], [DIR.RIGHT, Entity.FIREFLY3], [DIR.DOWN, Entity.FIREFLY4]]),
    BUTTERFLIES: array_of_tuples([[DIR.LEFT, Entity.BUTTERFLY1], [DIR.UP, Entity.BUTTERFLY2], [DIR.RIGHT, Entity.BUTTERFLY3], [DIR.DOWN, Entity.BUTTERFLY4]]),
    PREROCKFORDS: [Entity.PREROCKFORD1, Entity.PREROCKFORD2, Entity.PREROCKFORD3, Entity.PREROCKFORD, Entity.ROCKFORD],
    EXPLODETOSPACE: [Entity.EXPLODETOSPACE0, Entity.EXPLODETOSPACE1, Entity.EXPLODETOSPACE2, Entity.EXPLODETOSPACE3, Entity.EXPLODETOSPACE4, Entity.SPACE],
    EXPLODETODIAMOND: [Entity.EXPLODETODIAMOND0, Entity.EXPLODETODIAMOND1, Entity.EXPLODETODIAMOND2, Entity.EXPLODETODIAMOND3, Entity.EXPLODETODIAMOND4, Entity.DIAMOND]
  };

  Render = (function() {

    function Render(game, moving) {
      this.game = game;
      this.moving = moving;
      game.subscribe('level', this.onChangeLevel, this);
      game.subscribe('score', this.invalidateScore, this);
      game.subscribe('timer', this.invalidateScore, this);
      game.subscribe('flash', this.invalidateCave, this);
      game.subscribe('cell', this.invalidateCell, this);
    }

    Render.prototype.reset = function(sprites) {
      this.canvas = Dom.get('canvas');
      this.ctx = this.canvas.getContext('2d');
      this.sprites = sprites;
      this.fps = 30;
      this.step = 1 / this.fps;
      this.frame = 0;
      this.ctxSprites = document.createElement('canvas').getContext('2d');
      this.ctxSprites.canvas.width = this.sprites.width;
      this.ctxSprites.canvas.height = this.sprites.height;
      this.ctxSprites.drawImage(this.sprites, 0, 0, this.sprites.width, this.sprites.height, 0, 0, this.sprites.width, this.sprites.height);
      return this.resize();
    };

    Render.prototype.onChangeLevel = function(info) {
      this.description(info.description);
      this.colors(info.color1, info.color2);
      this.invalidateCave();
      this.invalidateScore();
      Dom.disable('prev', info.index === 0);
      return Dom.disable('next', info.index === CAVES.length - 1);
    };

    Render.prototype.invalid = {
      score: true,
      cave: true
    };

    Render.prototype.invalidateScore = function() {
      return this.invalid.score = true;
    };

    Render.prototype.invalidateCave = function() {
      return this.invalid.cave = true;
    };

    Render.prototype.invalidateCell = function(cell) {
      return cell.invalid = true;
    };

    Render.prototype.validateScore = function() {
      return this.invalid.score = false;
    };

    Render.prototype.validateCave = function() {
      return this.invalid.cave = false;
    };

    Render.prototype.validateCell = function(cell) {
      return cell.invalid = false;
    };

    Render.prototype.update = function() {
      this.frame++;
      this.score();
      this.game.eachCell(this.cell, this);
      return this.validateCave();
    };

    Render.prototype.score = function() {
      this.ctx.fillStyle = 'black';
      this.ctx.fillRect(0, 0, this.canvas.width, this.dy);
      this.number(3, this.game.diamonds.needed, 2, true);
      this.letter(5, '$');
      this.number(6, this.game.diamonds.collected >= (this.game.diamonds.needed ? this.game.diamonds.extra : this.game.diamonds.value), 2);
      this.number(12, this.game.diamonds.collected, 3, true);
      this.number(25, this.game.timer, 3);
      this.number(31, this.game.score, 6);
      return this.validateScore();
    };

    Render.prototype.number = function(x, n, width, yellow) {
      var i, word, _i, _ref, _results;
      word = ("000000" + n.toString()).slice(-(width || 2));
      _results = [];
      for (i = _i = 0, _ref = word.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.letter(x + i, word[i], yellow));
      }
      return _results;
    };

    Render.prototype.letter = function(x, c, yellow) {
      return this.ctx.drawImage(this.ctxSprites.canvas, (yellow ? 9 : 8) * 32, (c.charCodeAt(0) - 32) * 16, 32, 16, x * this.dx, 0, this.dx, this.dy - 4);
    };

    Render.prototype.cell = function(cell) {
      var object, sprite;
      object = cell.object;
      sprite = object.sprite;
      if (this.invalid.cave || cell.invalid || (sprite.f > 1) || (object === Entity.ROCKFORD)) {
        if (object === Entity.ROCKFORD) {
          return this.rockford(cell);
        } else {
          if ((object === Entity.SPACE) && (this.game.flash > this.game.frame)) {
            sprite = Entity.SPACE.flash;
          } else if (object === Entity.MAGICWALL && !this.game.magic.active) {
            sprite = Entity.BRICKWALL.sprite;
          }
          this.sprite(sprite, cell);
          this.validateCell(cell);
          return null;
        }
      }
    };

    Render.prototype.sprite = function(sprite, cell) {
      var f;
      f = sprite.f ? Math.floor((sprite.fps / this.fps) * this.frame) % sprite.f : 0;
      return this.ctx.drawImage(this.ctxSprites.canvas, (sprite.x + f) * 32, sprite.y * 32, 32, 32, cell.p.x * this.dx, (1 + cell.p.y) * this.dy, this.dx, this.dy);
    };

    Render.prototype.rockford = function(cell) {
      if (this.moving.dir === DIR.LEFT || vertical(this.moving.dir) && this.moving.lastXDir === DIR.LEFT) {
        return this.sprite(Entity.ROCKFORD.left, cell);
      } else if (this.moving.dir === DIR.RIGHT || vertical(this.moving.dir) && this.moving.lastXDir === DIR.RIGHT) {
        return this.sprite(Entity.ROCKFORD.right, cell);
      } else if (this.game.idle.blink && !this.game.idle.tap) {
        return this.sprite(Entity.ROCKFORD.blink, cell);
      } else if (!this.game.idle.blink && this.game.idle.tap) {
        return this.sprite(Entity.ROCKFORD.tap, cell);
      } else if (this.game.idle.blink && this.game.idle.tap) {
        return this.sprite(Entity.ROCKFORD.blinktap, cell);
      } else {
        return this.sprite(Entity.ROCKFORD.sprite, cell);
      }
    };

    Render.prototype.description = function(msg) {
      return Dom.set('description', msg);
    };

    Render.prototype.colors = function(color1, color2) {
      var color, n, pixels, x, y, _i, _j, _ref, _ref1;
      this.ctxSprites.drawImage(this.sprites, 0, 0, this.sprites.width, this.sprites.height, 0, 0, this.sprites.width, this.sprites.height);
      pixels = this.ctxSprites.getImageData(0, 0, this.sprites.width, this.sprites.height);
      for (y = _i = 0, _ref = this.sprites.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.sprites.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          n = (y * this.sprites.width * 4) + (x * 4);
          color = (pixels.data[n + 0] << 16) + (pixels.data[n + 1] << 8) + (pixels.data[n + 2] << 0);
          if (color === 0x3F3F3F) {
            pixels.data[n + 0] = (color2 >> 16) & 0xFF;
            pixels.data[n + 1] = (color2 >> 8) & 0xFF;
            pixels.data[n + 2] = (color2 >> 0) & 0xFF;
          } else if (color === 0xA52A00) {
            pixels.data[n + 0] = (color1 >> 16) & 0xFF;
            pixels.data[n + 1] = (color1 >> 8) & 0xFF;
            pixels.data[n + 2] = (color1 >> 0) & 0xFF;
          }
        }
      }
      return this.ctxSprites.putImageData(pixels, 0, 0);
    };

    Render.prototype.resize = function() {
      var visibleArea;
      visibleArea = {
        w: 40,
        h: 23
      };
      this.canvas.width = this.canvas.clientWidth;
      this.canvas.height = this.canvas.clientHeight;
      this.dx = this.canvas.width / visibleArea.w;
      this.dy = this.canvas.height / visibleArea.h;
      this.invalidateScore();
      return this.invalidateCave();
    };

    return Render;

  })();

  random = function(min, max) {
    return min + (Math.random() * (max - min));
  };

  randomInt = function(min, max) {
    return Math.floor(random(min, max));
  };

  randomChoice = function(choices) {
    return choices[Math.round(random(0, choices.length - 1))];
  };

  Game = (function() {

    function Game(moving, options) {
      this.options = options || {};
      this.storage = window.localStorage || {};
      this.score = 0;
      this.moving = moving;
    }

    Game.prototype.reset = function(n) {
      var x, y, _i, _j, _ref, _ref1;
      n = Math.min(CAVES.length - 1, Math.max(0, (typeof n === 'number' ? n : this.storage.level) || 0));
      this.index = this.storage.level = n;
      this.cave = CAVES[this.index];
      this.width = this.cave.width;
      this.height = this.cave.height;
      this.cells = [];
      this.frame = 0;
      this.fps = 10;
      this.step = 1 / this.fps;
      this.birth = 2 * this.fps;
      this.timer = this.cave.caveTime;
      this.idle = {
        blink: false,
        tap: false
      };
      this.flash = false;
      this.won = false;
      this.diamonds = {
        collected: 0,
        needed: this.cave.diamondsNeeded,
        value: this.cave.initialDiamondValue,
        extra: this.cave.extraDiamondValue
      };
      this.amoeba = {
        max: this.cave.amoebaMaxSize,
        slow: this.cave.amoebaSlowGrowthTime / this.step
      };
      this.magic = {
        active: false,
        time: this.cave.magicWallMillingTime / this.step,
        expired: false
      };
      for (y = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          this.cells[x] = this.cells[x] || [];
          this.cells[x][y] = {
            p: new Point(x, y),
            frame: 0,
            object: Entity[this.cave.map[x][y]]
          };
        }
      }
      return this.publish('level', this.cave);
    };

    Game.prototype.prev = function() {
      if (this.index > 0) {
        return this.reset(this.index - 1);
      }
    };

    Game.prototype.next = function() {
      if (this.index < CAVES.length - 1) {
        return this.reset(this.index + 1);
      }
    };

    Game.prototype.get = function(p, dir) {
      return this.cells[p.x + (DIRX[dir] || 0)][p.y + (DIRY[dir] || 0)].object;
    };

    Game.prototype.set = function(p, o, dir) {
      var cell;
      cell = this.cells[p.x + (DIRX[dir] || 0)][p.y + (DIRY[dir] || 0)];
      cell.object = o;
      cell.frame = this.frame;
      return this.publish('cell', cell);
    };

    Game.prototype.clear = function(p, dir) {
      return this.set(p, Entity.SPACE, dir);
    };

    Game.prototype.move = function(p, dir, o) {
      this.clear(p);
      return this.set(p, o, dir);
    };

    Game.prototype.isempty = function(p, dir) {
      return this.get(p, dir) === Entity.SPACE;
    };

    Game.prototype.isdirt = function(p, dir) {
      return this.get(p, dir) === Entity.DIRT;
    };

    Game.prototype.isboulder = function(p, dir) {
      return this.get(p, dir) === Entity.BOULDER;
    };

    Game.prototype.isrockford = function(p, dir) {
      return this.get(p, dir) === Entity.ROCKFORD;
    };

    Game.prototype.isdiamond = function(p, dir) {
      return this.get(p, dir) === Entity.DIAMOND;
    };

    Game.prototype.isamoeba = function(p, dir) {
      return this.get(p, dir) === Entity.AMOEBA;
    };

    Game.prototype.ismagic = function(p, dir) {
      return this.get(p, dir) === Entity.MAGICWALL;
    };

    Game.prototype.isoutbox = function(p, dir) {
      return this.get(p, dir) === Entity.OUTBOX;
    };

    Game.prototype.isfirefly = function(p, dir) {
      return isFirefly(this.get(p, dir));
    };

    Game.prototype.isbutterfly = function(p, dir) {
      return isButterfly(this.get(p, dir));
    };

    Game.prototype.isexplodable = function(p, dir) {
      return this.get(p, dir).explodable;
    };

    Game.prototype.isvulnerable = function(p, dir) {
      return this.get(p, dir).vulnerable;
    };

    Game.prototype.isrounded = function(p, dir) {
      return this.get(p, dir).rounded;
    };

    Game.prototype.isfallingdiamond = function(p, dir) {
      return this.get(p, dir) === Entity.DIAMONDFALLING;
    };

    Game.prototype.isfallingboulder = function(p, dir) {
      return this.get(p, dir) === Entity.BOULDERFALLING;
    };

    Game.prototype.eachCell = function(fn, thisArg) {
      var x, y, _i, _ref, _results;
      _results = [];
      for (y = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (x = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(fn.call(thisArg || this, this.cells[x][y]));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Game.prototype.update = function() {
      this.beginFrame();
      this.eachCell(function(cell) {
        if (cell.frame < this.frame) {
          return this.entityDispatch(cell.object, cell.p, this.moving.dir);
        }
      });
      return this.endFrame();
    };

    Game.prototype.subscribe = function(event, callback, target) {
      this.subscribers = this.subscribers || {};
      this.subscribers[event] = this.subscribers[event] || [];
      return this.subscribers[event].push({
        callback: callback,
        target: target
      });
    };

    Game.prototype.publish = function(event) {
      var args, n, sub, subs, _i, _ref, _results;
      if (this.subscribers && this.subscribers[event]) {
        subs = this.subscribers[event];
        args = [].slice.call(arguments, 1);
        _results = [];
        for (n = _i = 0, _ref = subs.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; n = 0 <= _ref ? ++_i : --_i) {
          sub = subs[n];
          _results.push(sub.callback.apply(sub.target, args));
        }
        return _results;
      }
    };

    Game.prototype.decreaseTimer = function(n) {
      this.timer = Math.max(0, this.timer - (n || 1));
      this.publish('timer', this.timer);
      return this.timer === 0;
    };

    Game.prototype.autoDecreaseTimer = function() {
      if ((this.frame > this.birth) && ((this.frame % this.fps) === 0)) {
        return this.decreaseTimer(1);
      }
    };

    Game.prototype.runOutTimer = function() {
      var amount;
      amount = Math.min(3, this.timer);
      this.increaseScore(amount);
      if (this.decreaseTimer(amount)) {
        return this.next();
      }
    };

    Game.prototype.collectDiamond = function() {
      this.diamonds.collected++;
      this.increaseScore(this.diamonds.collected > this.diamonds.needed ? this.diamonds.extra : this.diamonds.value);
      return this.publish('diamond', this.diamonds);
    };

    Game.prototype.increaseScore = function(n) {
      this.score += n;
      return this.publish('score', this.score);
    };

    Game.prototype.flashWhenEnoughDiamondsCollected = function() {
      if ((!this.flash) && (this.diamonds.collected >= this.diamonds.needed)) {
        this.flash = this.frame + Math.round(this.fps / 5);
      }
      if (this.frame <= this.flash) {
        return this.publish('flash');
      }
    };

    Game.prototype.loseLevel = function() {
      return this.reset();
    };

    Game.prototype.winLevel = function() {
      return this.won = true;
    };

    Game.prototype.beginFrame = function() {
      this.frame++;
      this.amoeba.size = 0;
      this.amoeba.enclosed = true;
      return this.idle = this.moving.dir ? {} : {
        blink: randomInt(1, 4) === 1 ? !this.idle.blink : this.idle.blink,
        tap: randomInt(1, 16) === 1 ? !this.idle.tap : this.idle.tap
      };
    };

    Game.prototype.endFrame = function() {
      if (!this.amoeba.dead) {
        if (this.amoeba.enclosed) {
          this.amoeba.dead = Entity.DIAMOND;
        } else if (this.amoeba.size > this.amoeba.max) {
          this.amoeba.dead = Entity.BOULDER;
        } else if (this.amoeba.slow > 0) {
          this.amoeba.slow--;
        }
      }
      if (this.magic.active) {
        if (--this.magic.time <= 0) {
          this.magic.active = false;
          this.magic.expired = true;
        }
      }
      this.flashWhenEnoughDiamondsCollected();
      if (this.won) {
        return this.runOutTimer();
      } else if (this.frame - this.foundRockford > (4 * this.fps)) {
        return this.loseLevel();
      } else {
        return this.autoDecreaseTimer();
      }
    };

    Game.prototype.updatePreRockford = function(p, n) {
      if (this.frame >= this.birth) {
        return this.set(p, Sequences.PREROCKFORDS[n + 1]);
      }
    };

    Game.prototype.updatePreOutbox = function(p) {
      if (this.diamonds.collected >= this.diamonds.needed) {
        return this.set(p, Entity.OUTBOX);
      }
    };

    Game.prototype.doGrab = function(p, dir) {
      if (this.isdirt(p, dir)) {
        return this.clear(p, dir);
      } else if (this.isdiamond(p, dir) || this.isfallingdiamond(p, dir)) {
        this.clear(p, dir);
        return this.collectDiamond();
      } else if (horizontal(dir) && this.isboulder(p, dir)) {
        return this.push(p, dir);
      } else {
        return null;
      }
    };

    Game.prototype.updateRockford = function(p, dir) {
      this.foundRockford = this.frame;
      if (this.won) {
        return null;
      } else if (this.timer === 0) {
        return this.explode(p);
      } else if (this.moving.grab) {
        return this.doGrab(p, dir);
      } else if (this.isempty(p, dir) || this.isdirt(p, dir)) {
        return this.move(p, dir, Entity.ROCKFORD);
      } else if (this.isdiamond(p, dir)) {
        this.move(p, dir, Entity.ROCKFORD);
        return this.collectDiamond();
      } else if (horizontal(dir) && this.isboulder(p, dir)) {
        return this.push(p, dir);
      } else if (this.isoutbox(p, dir)) {
        this.move(p, dir, Entity.ROCKFORD);
        return this.winLevel();
      }
    };

    Game.prototype.updateRock = function(p, fallingRock) {
      if (this.isempty(p, DIR.DOWN)) {
        return this.move(p, DIR.DOWN, fallingRock);
      } else if (this.isrounded(p, DIR.DOWN) && this.isempty(p, DIR.LEFT) && this.isempty(p, DIR.DOWNLEFT)) {
        return this.move(p, DIR.LEFT, fallingRock);
      } else if (this.isrounded(p, DIR.DOWN) && this.isempty(p, DIR.RIGHT) && this.isempty(p, DIR.DOWNRIGHT)) {
        return this.move(p, DIR.RIGHT, fallingRock);
      }
    };

    Game.prototype.updateRockFalling = function(p, fallingRock, rockAtRest, convertedRock) {
      if (this.isempty(p, DIR.DOWN)) {
        return this.move(p, DIR.DOWN, fallingRock);
      } else if (this.isvulnerable(p, DIR.DOWN)) {
        return this.explode_dir(p, DIR.DOWN);
      } else if (this.ismagic(p, DIR.DOWN)) {
        return this.domagic(p, convertedRock);
      } else if (this.isrounded(p, DIR.DOWN) && this.isempty(p, DIR.LEFT) && this.isempty(p, DIR.DOWNLEFT)) {
        return this.move(p, DIR.LEFT, fallingRock);
      } else if (this.isrounded(p, DIR.DOWN) && this.isempty(p, DIR.RIGHT) && this.isempty(p, DIR.DOWNRIGHT)) {
        return this.move(p, DIR.RIGHT, fallingRock);
      } else {
        return this.set(p, rockAtRest);
      }
    };

    Game.prototype.updateBoulder = function(p) {
      return this.updateRock(p, Entity.BOULDERFALLING);
    };

    Game.prototype.updateDiamond = function(p) {
      return this.updateRock(p, Entity.DIAMONDFALLING);
    };

    Game.prototype.updateBoulderFalling = function(p) {
      return this.updateRockFalling(p, Entity.BOULDERFALLING, Entity.BOULDER, Entity.DIAMOND);
    };

    Game.prototype.updateDiamondFalling = function(p) {
      return this.updateRockFalling(p, Entity.DIAMONDFALLING, Entity.DIAMOND, Entity.BOULDER);
    };

    Game.prototype.adjacent = function(p, fn) {
      var dirs, i, rv, _i, _ref;
      dirs = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
      rv = false;
      for (i = _i = 0, _ref = dirs.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (fn(p, dirs[i])) {
          rv = true;
        }
      }
      return rv;
    };

    Game.prototype.updateFly = function(p, dir, newdir, olddir, phases) {
      var by_amoeba, by_rockford, self;
      self = this;
      by_rockford = function(p, d) {
        return self.isrockford(p, d);
      };
      by_amoeba = function(p, d) {
        return self.isamoeba(p, d);
      };
      if (this.adjacent(p, by_rockford) || this.adjacent(p, by_amoeba)) {
        this.explode(p);
        return null;
      } else {
        if (this.isempty(p, newdir)) {
          return this.move(p, newdir, phases[newdir]);
        } else if (this.isempty(p, dir)) {
          return this.move(p, dir, phases[dir]);
        } else {
          return this.set(p, phases[olddir]);
        }
      }
    };

    Game.prototype.updateFirefly = function(p, dir) {
      return this.updateFly(p, dir, rotateLeft(dir), rotateRight(dir), Sequences.FIREFLIES);
    };

    Game.prototype.updateButterfly = function(p, dir) {
      return this.updateFly(p, dir, rotateRight(dir), rotateLeft(dir), Sequences.BUTTERFLIES);
    };

    Game.prototype.updateExplodeToSpace = function(p, n) {
      return this.set(p, Sequences.EXPLODETOSPACE[n + 1]);
    };

    Game.prototype.updateExplodeToDiamond = function(p, n) {
      return this.set(p, Sequences.EXPLODETODIAMOND[n + 1]);
    };

    Game.prototype.updateAmoeba = function(p) {
      var by_dirt, by_empty, dir, grow, self;
      if (this.amoeba.dead) {
        return this.set(p, this.amoeba.dead);
      } else {
        self = this;
        by_empty = function(p, d) {
          return self.isempty(p, d);
        };
        by_dirt = function(p, d) {
          return self.isdirt(p, d);
        };
        this.amoeba.size++;
        if (this.adjacent(p, by_empty) || this.adjacent(p, by_dirt)) {
          this.amoeba.enclosed = false;
        }
        if (this.frame >= this.birth) {
          grow = this.amoeba.slow ? randomInt(1, 128) < 4 : randomInt(1, 4) === 1;
          dir = randomChoice([DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT]);
          if (grow && (this.isdirt(p, dir) || this.isempty(p, dir))) {
            return this.set(p, Entity.AMOEBA, dir);
          }
        }
      }
    };

    Game.prototype.explode = function(p) {
      var dir, explosion, _i, _results;
      explosion = this.isbutterfly(p) ? Entity.EXPLODETODIAMOND0 : Entity.EXPLODETOSPACE0;
      this.set(p, explosion);
      _results = [];
      for (dir = _i = 0; _i <= 7; dir = ++_i) {
        if (this.isexplodable(p, dir)) {
          _results.push(this.set(p, explosion, dir));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.explode_dir = function(p, dir) {
      var p2;
      p2 = new Point(p.x, p.y, dir);
      return this.explode(p2);
    };

    Game.prototype.push = function(p, dir) {
      var p2;
      p2 = new Point(p.x, p.y, dir);
      if (this.isempty(p2, dir)) {
        if (randomInt(1, 8) === 1) {
          this.move(p2, dir, Entity.BOULDER);
          if (!this.moving.grab) {
            return this.move(p, dir, Entity.ROCKFORD);
          }
        }
      }
    };

    Game.prototype.convert = function(p, to) {
      var p2;
      this.clear(p);
      p2 = new Point(p.x, p.y + 2);
      if (this.isempty(p2)) {
        return this.set(p2, to);
      }
    };

    Game.prototype.domagic = function(p, to) {
      if (this.magic.time > 0) {
        this.magic.active = true;
        return this.convert(p, to);
      } else if (this.magic.expired) {
        return this.convert(p, Entity.SPACE);
      }
    };

    Game.prototype.entityDispatch = function(e, p, moving_dir) {
      switch (e) {
        case Entity.PREROCKFORD1:
          return this.updatePreRockford(p, 1);
        case Entity.PREROCKFORD2:
          return this.updatePreRockford(p, 2);
        case Entity.PREROCKFORD3:
          return this.updatePreRockford(p, 3);
        case Entity.PREROCKFORD4:
          return this.updatePreRockford(p, 4);
        case Entity.ROCKFORD:
          return this.updateRockford(p, moving_dir);
        case Entity.BOULDER:
          return this.updateBoulder(p);
        case Entity.BOULDERFALLING:
          return this.updateBoulderFalling(p);
        case Entity.DIAMOND:
          return this.updateDiamond(p);
        case Entity.DIAMONDFALLING:
          return this.updateDiamondFalling(p);
        case Entity.FIREFLY1:
          return this.updateFirefly(p, DIR.LEFT);
        case Entity.FIREFLY2:
          return this.updateFirefly(p, DIR.UP);
        case Entity.FIREFLY3:
          return this.updateFirefly(p, DIR.RIGHT);
        case Entity.FIREFLY4:
          return this.updateFirefly(p, DIR.DOWN);
        case Entity.BUTTERFLY1:
          return this.updateButterfly(p, DIR.LEFT);
        case Entity.BUTTERFLY2:
          return this.updateButterfly(p, DIR.UP);
        case Entity.BUTTERFLY3:
          return this.updateButterfly(p, DIR.RIGHT);
        case Entity.BUTTERFLY4:
          return this.updateButterfly(p, DIR.DOWN);
        case Entity.EXPLODETOSPACE0:
          return this.updateExplodeToSpace(p, 0);
        case Entity.EXPLODETOSPACE1:
          return this.updateExplodeToSpace(p, 1);
        case Entity.EXPLODETOSPACE2:
          return this.updateExplodeToSpace(p, 2);
        case Entity.EXPLODETOSPACE3:
          return this.updateExplodeToSpace(p, 3);
        case Entity.EXPLODETOSPACE4:
          return this.updateExplodeToSpace(p, 4);
        case Entity.EXPLODETODIAMOND0:
          return this.updateExplodeToDiamond(p, 0);
        case Entity.EXPLODETODIAMOND1:
          return this.updateExplodeToDiamond(p, 1);
        case Entity.EXPLODETODIAMOND2:
          return this.updateExplodeToDiamond(p, 2);
        case Entity.EXPLODETODIAMOND3:
          return this.updateExplodeToDiamond(p, 3);
        case Entity.EXPLODETODIAMOND4:
          return this.updateExplodeToDiamond(p, 4);
        case Entity.AMOEBA:
          return this.updateAmoeba(p);
        case Entity.PREOUTBOX:
          return this.updatePreOutbox(p);
      }
    };

    return Game;

  })();

  timestamp = function() {
    return new Date().getTime();
  };

  KEY = {
    ENTER: 13,
    ESC: 27,
    SPACE: 32,
    PAGEUP: 33,
    PAGEDOWN: 34,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
  };

  moving = {
    dir: DIR.NONE,
    lastXDir: DIR.NONE,
    up: false,
    down: false,
    left: false,
    right: false,
    grab: false,
    startUp: function() {
      this.up = true;
      return this.dir = DIR.UP;
    },
    startDown: function() {
      this.down = true;
      return this.dir = DIR.DOWN;
    },
    startLeft: function() {
      this.left = true;
      this.dir = DIR.LEFT;
      return this.lastXDir = DIR.LEFT;
    },
    startRight: function() {
      this.right = true;
      this.dir = DIR.RIGHT;
      return this.lastXDir = DIR.RIGHT;
    },
    startGrab: function() {
      return this.grab = true;
    },
    stopUp: function() {
      this.up = false;
      return this.dir = this.dir === DIR.UP ? this.where() : this.dir;
    },
    stopDown: function() {
      this.down = false;
      return this.dir = this.dir === DIR.DOWN ? this.where() : this.dir;
    },
    stopLeft: function() {
      this.left = false;
      return this.dir = this.dir === DIR.LEFT ? this.where() : this.dir;
    },
    stopRight: function() {
      this.right = false;
      return this.dir = this.dir === DIR.RIGHT ? this.where() : this.dir;
    },
    stopGrab: function() {
      return this.grab = false;
    },
    where: function() {
      if (this.up) {
        return DIR.UP;
      } else if (this.down) {
        return DIR.DOWN;
      } else if (this.left) {
        return DIR.LEFT;
      } else if (this.right) {
        return DIR.RIGHT;
      }
    }
  };

  game = new Game(moving);

  render = new Render(game, moving);

  stats = new Stats();

  run = function() {
    var dt, frame, gdt, last, rdt;
    last = timestamp();
    dt = 0;
    gdt = 0;
    rdt = 0;
    frame = function() {
      var now;
      now = timestamp();
      dt = Math.min(1, (now - last) / 1000);
      gdt = gdt + dt;
      while (gdt > game.step) {
        gdt = gdt - game.step;
        game.update();
      }
      rdt = rdt + dt;
      if (rdt > render.step) {
        rdt = rdt - render.step;
        render.update();
      }
      stats.update();
      last = now;
      return requestAnimationFrame(frame, render.canvas);
    };
    return load(function(sprites) {
      render.reset(sprites);
      game.reset();
      addEvents();
      showStats();
      return frame();
    });
  };

  load = function(cb) {
    var sprites;
    sprites = document.createElement('img');
    sprites.addEventListener('load', (function() {
      return cb(sprites);
    }), false);
    return sprites.src = 'images/sprites.png';
  };

  showStats = function() {
    stats.domElement.id = 'stats';
    return Dom.get('boulderdash').appendChild(stats.domElement);
  };

  addEvents = function() {
    document.addEventListener('keydown', keydown, false);
    document.addEventListener('keyup', keyup, false);
    window.addEventListener('resize', (function() {
      return render.resize();
    }), false);
    Dom.get('prev').addEventListener('click', (function() {
      return game.prev();
    }), false);
    return Dom.get('next').addEventListener('click', (function() {
      return game.next();
    }), false);
  };

  keydown = function(ev) {
    var handled;
    handled = true;
    switch (ev.keyCode) {
      case KEY.UP:
        moving.startUp();
        break;
      case KEY.DOWN:
        moving.startDown();
        break;
      case KEY.LEFT:
        moving.startLeft();
        break;
      case KEY.RIGHT:
        moving.startRight();
        break;
      case KEY.ESC:
        game.reset();
        break;
      case KEY.PAGEUP:
        game.prev();
        break;
      case KEY.PAGEDOWN:
        game.next();
        break;
      case KEY.SPACE:
        moving.startGrab();
        break;
      default:
        handled = false;
    }
    if (handled) {
      return ev.preventDefault();
    }
  };

  keyup = function(ev) {
    var handled;
    handled = true;
    switch (ev.keyCode) {
      case KEY.UP:
        moving.stopUp();
        break;
      case KEY.DOWN:
        moving.stopDown();
        break;
      case KEY.LEFT:
        moving.stopLeft();
        break;
      case KEY.RIGHT:
        moving.stopRight();
        break;
      case KEY.SPACE:
        moving.stopGrab();
        break;
      default:
        handled = false;
    }
    if (handled) {
      return ev.preventDefault();
    }
  };

  run.game = game;

  run.render = render;

  run();

}).call(this);
